---
title: '搜尋演算法筆記(1)'
description: '線性搜尋和二分搜尋'
date: '2023-10-24'
category: 'Alogorithm'
tags:
  - Alogorithm
  - Search
---

# 搜尋演算法筆記(1)

## 線性搜尋法 Linear Search
- 又稱為循序搜尋(Sequential Search)

### 說明
- 是最簡單的搜尋法
- 原理是在資料列中從頭開始逐一的搜尋，一筆一筆的資料值與搜尋目標值做比對，直到找到為止
- 時間複雜度：O(n)  

### 步驟
 1. 使用for迴圈，把目標數和陣列中的數一個一個比較
 2. 如果找到，就停止迴圈
 3. 如果全部比對完仍沒有找到，回傳`-1`，表示目標元素不存在於陣列中
### 範例
```js
const numbers = [1, 3, 5, 7, 9, 12, 15, 18. 21, 24]

function linearSearch(arr, n){
	for(let i = 0; i < arr.length; i++){
	if(arr[i] === n){
			console.log('找到n了')
			return
		}
	}
	console.log('沒有找到n')
	return -1 
}

linearSearch(numbers, 21)

```
## 二分搜尋法

### 說明
- 當資料已經是排列好的狀態
- 在已排序好的資料列中找出中間值，再將搜尋的目標值與中間值作比較
- 如果目標值小於中間值，則往左邊資料列尋找
- 如果目標值大於中間值，則往右邊資料列尋找
- 時間複雜度：O(log n)

### 步驟
1. 先把陣列中的第一個數（left） 和最後一個數（right）的Index拿出來
2. 當left <= right的時候，代表還沒找到目標值
3. 以這兩個數來取中間值 (middle)
4. 把目標值和中間值比對
	- **大於中間值**：如果 `n` 大於 `arr[middle]`，則 `n` 只可能存在於 `middle` 之後的部分
	- 將 `min` 設為 `middle + 1`
	- **小於中間值**：如果 `n` 小於 `arr[middle]`，則 `n` 只可能存在於 `middle` 之前的部分
	- 將`max` 設為 `middle - 1`
	- **等於中間值**：如果 `n` 等於 `arr[middle]`，則已經找到了目標元素，返回 `middle`
5. 繼續重複2~4步驟，直到 left <= max 為止
6. 如果迴圈結束還沒有找到目標元素，那麼回傳 `-1`，表示目標元素不存在於陣列中

### 範例


```js
const numbers = [2, 4, 6, 8, 10, 122, 144, 166, 188, 200, 220, 240, 280]

function binarySearch(arr, n){
	let min = 0
	let max = arr.length - 1
	
	while(min <= max) {
		let middle = Math.floor((max + min)/ 2 )	
		if(n > arr[middle]){
			min = middle + 1
		}else if (n < arr[middle]){
			max = middle - 1
		}else if (n === arr[middle]) 
			{
			return middle	
		}	
	}
	return -1
}

console.log(binarySearch(numbers, 122)); // 5
console.log(binarySearch(numbers, 7)); // -1


```

### 備註
- 設定迴圈條件 left <= right ，是因為可能陣列中只有一個數字的狀況
- 範例
```js
const arr = [6]
left = 0
right = 0 

// 如果設定 right < left 會回傳-1，導致結果錯誤
```
## 參考資料
- [JavaScript 學演算法（二十）- 搜尋演算法](https://chupai.github.io/posts/2008/search_algorithm/)
- [Binary Search Algorithm in 100 Seconds](https://www.youtube.com/watch?v=MFhxShGxHWc)